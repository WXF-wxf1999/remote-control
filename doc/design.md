# Android远程控制PC的设计

## 总体设想

一般地，需要远程控制的两端不在同一局域网内，需要具有公网地址的第三方进行中转，所以整个项目分为三个部分：Android移动控制端、Linux/Windows被控端、Linux服务器。在采用开发语言方面，考虑到被控端的跨平台性，使用Java进行开发；Android移动端使用Java语言，服务器部分采用C/C++进行开发。

## 功能规划

1.服务端（Linux）

​	1）用户登录管控。

​	2）与主控端和被控端建立通信连接。

​	3）数据的中转

2.控制端（Android）

​	1）远程共享PC桌面。

​    2）远程掌控PC端键鼠输入。

​    3）搜索下载指定的PC端文件。

​	4）拓展功能。

3.被控端（Linux/Windows）

​	1）解析并执行主控端的命令，反馈相应的数据。

## 细节设想与分析

### 网络协议

TCP和UDP均有各自的优点，UDP"打洞"比较容易实现，能够建立控制端、被控端的P2P，服务器只是初始建立两方连接的媒介，后续的数据传输与服务器无关，但是UDP打洞也是概率成功， 网关均要求为Cone NAT类型。Symmetric NAT不适合。采用TCP"打洞"要比UDP复杂的多，在协议层次虽然两者类似，但是TCP本身复杂，支持的NAT比较少。如果使用TCP协议，只能通过服务器完全转发发送方的数据，对服务器的负载能力要求较高。但考虑到开发的技术难度和日后传输数据的完整性要求上，本项目采用TCP协议。

### 网络框架

对于控制端和被控端，采用高性能、异步事件框架的Netty网络编程框架，在尽可能较少客户端开销的情况下得到较好的并发性；对于服务器，目前为止，各大主流网络框架使用的网络IO模型都是epoll多路复用模型，其本质上还是同步IO。而异步IO操作在数据准备阶段和数据拷贝阶段均是由内核来完成的，异步IO更为方便和高效，之前真正的异步IO模型，在Windows这块（Io Completion Port）反而是领先的。但最近几年，Linux内核也推出了高性能的异步I/O框架（io_uring），能显著加速IO密集型应用的性能，使用新颖的方法值得一试，使用io_uring编程中采用主从Reactor模式以尽可能提高服务器程序的并发性。

### 数据传输

数据传输包括命令的传输、图像数据、文件数据的传输，一个数据包会有双方约定的数据格式。接收方手动地按照长度格式解析读取数据包中的内容是一种普通的方案，但是对象序列化则是一种更好的选择。对将要发送的结构数据进行序列化，接收方使用提供的方法进行快捷地读取，从而实现数据的传输与解析。并且能够解决Netty中可能出现的TCP粘包问题。使用C语言中的结构体就能够实现序列化的功能，但是考虑到本项目由不同的平台系统、不同的语言组成，不同的语言结构体的定义方式不同，不能直接解析，并且结构体存在内存粒度对齐的问题，所以在数据传输中，使用语言无关、平台无关的——Google的protobuf数据协议。

### 消息分发

通过switch case分发消息类型，一般开始可能只有几个，但是几次迭代之后就可能比较麻烦，代码不易拓展和维护，也不符合开闭原则。所以设想采用多态+反射+Map的方法实现消息分发，具体设计如下：

（1）每一个消息类型对应实现一个处理类。

（2）接受方根据数据传输协议获得消息类型对应消息处理类的类名字符串。

（3）在 `Map<String objectName，AbstarctHandler abstractHandler> `中获得对应消息处理类的父类指针返回，如果Map中没有则利用`objectName`进行反射加载类，然后将该类名和类的上行转换的父类类型存储进Map中。

（4）调用上行转化为父类类型的子类对象，利用父类指针指向的不同子类对象时产生的不同动作的多态实现消息的分发处理。

![dispatch](.\pictures\dispatch.png)



### 远程桌面

以很小的间隔在被控端进行屏幕截图，然后发送到控制端进行显示，能够显示较为流畅的远程桌面。对于远程PC的键鼠控制方面，可以使用Java中的Robot类为应用程序生成本机的系统输入事件。现有的被控端PC几乎肯定和Android控制端有着不同的屏幕宽高比，在控制端监听的光标位置不等同于在被控端的相应位置，所以现有的思路是根据控制端的光标位置，采取宽高比列换算的方式得到被控端对应位置上的坐标然后进行模拟，这样计算的得到的对应光标位置精度需要实际验证。

### 图像处理

图像数据的传输对于控制命令来说数据量要大许多，这会导致带宽消耗较高，为了减少传输的数据量，可以采用两种方式：

#### （1）压缩图像

对图像进行等比例压缩。

#### （2）区域检测

对得到的图像矩阵进行分区域，屏幕的变化在多数情况下只是部分变化，所以只需要将变化的区域进行数据传输即可。将得到的图像矩阵进行水平方向平分为若干子矩阵，对若干局域进行hash，对比上一次图像矩阵和本次图像矩阵对应的区域部分，有选择地将有变化的部分发送到控制端，控制端将变化部分的像素矩阵进行替换重新显示。

## 基本流图

这是描述大体功能的流程图：

![flow_chart](.\pictures\flowsheet.png)

## 功能层级

 从粗略的角度看，目前整个项目分为三个层级：UI层、Handler层（命令分发和处理）、网络层（数据传输）。这三层结构在基本流程图中也有体现。

![level](.\pictures\rank.png)





